# -*- coding: utf-8 -*-
"""Numpy.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FV1exN14dlJBzmbOB8UUsc2FiJF-eTPJ
"""

import pandas as pd
import numpy as np

a=[2,3,4]
b=[4,7,9]
sum(a+b)

#to calculate individual summation we need to use numpy
np_a=np.array(a)
np_b=np.array(b)

np_a + np_b

#Numpy Array only uses single data type otherwise changes to string if mixed
p=np.array([1,2,'abv'])
p

#Bool values are converted to binary
q=np.array([1,5,True,False])
q

#Different arrays don't add up
# p+q

q.max()

q.mean()

q.min()

np.ones(4)

np.zeros(2)

# Only normal multiplication can be performed
q*3

q*[2]

# Array_Broadcasting: Makes N-Dimen. array matching to initial array
# Helps in assigning weights to features
q*np.array([2.2])

# Different values cannot be broadcasted, either the N-D should be 1 or equal
# q*np.array([2.2,4.4])

# list functions work on n-d array
q

q[1]

q[1:]

q_2d=np.array([[1,2],[3,4]])
q_2d

q_2d.sum()

# Axis 0 = Column
# Axis 1 =Row
q_2d.sum(axis=0)

# 2-d arrays are matrices, All above are tensors: 3-d,4-d tensors
# Matrices can be tranasposed
q_2d.transpose()
q_2d.T

# To generate identity matrix: np.eye(dimension)
np.eye(2)

# Can define ones and zeros in N-d
np.ones([2,2])

np.zeros([2,1])

q_2d

# Broadcaasting accross Matrices
q_2d+np.eye(2,1)

# Dot product can only be performed when dimension match i.r Col = Row
q_dot=q_2d.dot(np.ones([2,3]))
q_dot

q_2d.shape

q_dot.shape

# use random function to generate arrays
np_reshape=np.random.random(6)
np_reshape

# Reshaping to match dimension of data: np.reshape(row,col)
# Use col = -1 if don't know dimension and give only rows
np_reshape.reshape(2,3)

np_reshape.reshape(1,-1)

# -----------------------------------------------------------------------------#
# To use Linear Algebra
import numpy.linalg as la

q_2d

# Inverse Matrix
la.inv(q_2d)

# Find Eigen Values
la.eig(q_2d)

np.random.shuffle(np_reshape)
np_reshape

# To generate b/w 0,1
np.random.rand(2,3)

# To generate b/w a range: randint(range,dim.)
np.random.randint(1,10,6)

# To generate between standard normal/binomial
np.random.randn(3,2)

# Find success with particular prob. in given trial using Binomial and which points succed
np.random.binomial(20,0.4,6)

#Exponential Distribution using lambda and no of points
np.random.exponential(0.7,5)

# Use normal distribution using mean and std dev
np.random.normal(4,1.5,5)

# Logistic Distribution
np.random.logistic(2,4,7)

# To stack array over array: Enter in tuple
np.vstack((np_reshape.reshape(3,-1),q_2d))

np.hstack((np_reshape.reshape(2,-1),q_2d))

# Commented out IPython magic to ensure Python compatibility.
# # Use %%time to find time taken for processes
# %%time
# q_2d+np.random.randint(1,65443,[2,2])

0